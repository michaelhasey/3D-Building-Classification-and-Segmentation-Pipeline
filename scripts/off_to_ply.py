# -*- coding: utf-8 -*-
"""obj_to_ply_to_hd5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1c0p_IsxT2TVhyuHFJC2ez7csM4F5Q3Ar

### Step1: Convert .off to .npy or .ply format
"""
# ******************************************************************************
# Identify which building typology to convert
typology = "row"
# ******************************************************************************

# Import dependencies
import numpy as np
import math
import random
import os
import torch
import scipy.spatial.distance
import time
import h5py
import numpy as np
import plotly.graph_objects as go
import plotly.express as px
import open3d as o3d
import sys
import scipy.io
from torch.utils.data import Dataset, DataLoader
from torchvision import transforms, utils
from plyfile import PlyData, PlyElement


# Set random seed
random.seed = 42

# Data

# Set path to off files to convert
path = f'data/2_preprocessing_files/3_off/{typology}'

# Define folder to search through
# Define building classes (typologies)
# folders = [dir for dir in sorted(os.listdir(path)) if os.path.isdir(path/dir)]
# classes = {folder: i for i, folder in enumerate(folders)};
# classes

# Read ".off" file type function
def read_off(file):
    if 'OFF' != file.readline().strip():
        raise('Not a valid OFF header')
    n_verts, n_faces, __ = tuple([int(s) for s in file.readline().strip().split(' ')])
    verts = [[float(s) for s in file.readline().strip().split(' ')] for i_vert in range(n_verts)]
    faces = [[int(s) for s in file.readline().strip().split(' ')][1:] for i_face in range(n_faces)]
    return verts, faces

# Point sample function
# Samples uniform points along surface
class PointSampler(object):
    def __init__(self, output_size):
        assert isinstance(output_size, int)
        self.output_size = output_size
    
    def triangle_area(self, pt1, pt2, pt3):
        side_a = np.linalg.norm(pt1 - pt2)
        side_b = np.linalg.norm(pt2 - pt3)
        side_c = np.linalg.norm(pt3 - pt1)
        s = 0.5 * ( side_a + side_b + side_c)
        return max(s * (s - side_a) * (s - side_b) * (s - side_c), 0)**0.5

    def sample_point(self, pt1, pt2, pt3):
        # barycentric coordinates on a triangle
        # https://mathworld.wolfram.com/BarycentricCoordinates.html
        s, t = sorted([random.random(), random.random()])
        f = lambda i: s * pt1[i] + (t-s)*pt2[i] + (1-t)*pt3[i]
        return (f(0), f(1), f(2))
        
    
    def __call__(self, mesh):
        verts, faces = mesh
        verts = np.array(verts)
        areas = np.zeros((len(faces)))

        for i in range(len(areas)):
            areas[i] = (self.triangle_area(verts[faces[i][0]],
                                           verts[faces[i][1]],
                                           verts[faces[i][2]]))
            
        sampled_faces = (random.choices(faces, 
                                      weights=areas,
                                      cum_weights=None,
                                      k=self.output_size))
        
        sampled_points = np.zeros((self.output_size, 3))

        for i in range(len(sampled_faces)):
            sampled_points[i] = (self.sample_point(verts[sampled_faces[i][0]],
                                                   verts[sampled_faces[i][1]],
                                                   verts[sampled_faces[i][2]]))
        
        return sampled_points

# Normalize point cloud function via unit sphere
# This converts all points into a range between -1 & 1 in order to 
# standardize final point cloud size
class Normalize(object):
    def __call__(self, pointcloud):
        assert len(pointcloud.shape)==2
        
        norm_pointcloud = pointcloud - np.mean(pointcloud, axis=0) 
        norm_pointcloud /= np.max(np.linalg.norm(norm_pointcloud, axis=1))

        return  norm_pointcloud

# Create tensor object
# This will be used to convert point cloud into tensor
class ToTensor(object):
    def __call__(self, pointcloud):
        assert len(pointcloud.shape)==2

        return torch.from_numpy(pointcloud)

# Identify input / output folder
input_folder = f'data/2_preprocessing_files/3_off/{typology}'
output_folder = f'data/2_preprocessing_files/4_ply/{typology}'

# Identify number of points to sample
num_points = 2048

def off_to_ply():

  directory  = path

  count = 0

  for filename in os.listdir(directory):

    count += 1

    if filename.endswith(".off"):

      # Assign a test building geometry (.off file) to vert & face
      # variable to then use and visualize
      with open(path + "/" + filename, 'r') as f:
        verts, faces = read_off(f)

      # assign Test building geometry verticies (x,y,z) and faces to variables
      i,j,k = np.array(faces).T
      x,y,z = np.array(verts).T

      # Assign pointcloud variable and define number of points to sample
      # 2048 point are uniformly sampled to match PointNet paper
      pointcloud = PointSampler(num_points)((verts, faces))

      # Normalize point cloud
      norm_pointcloud = Normalize()(pointcloud)

      # convert point cloud into tensor
      ToTensor()(norm_pointcloud)

      # Create new zero numpy array in same shape as prev. np array
      new_array = np.zeros((num_points,3), dtype = float)


      # Fix x,y,z axis so building displayed correctly
      # Shuffle vertices of original np file to flip building so it looks correctly.
      # This entails shuffling the x,y,z values of all vertices as follows:
      # X,Y,Z ---> Z, X, Y
      # This re-assigns the X axis value to the previous Z value, and so on

      new_array[:,0] = norm_pointcloud[:,2]
      new_array[:,1] = norm_pointcloud[:,0]
      new_array[:,2] = norm_pointcloud[:,1]

      #************************************************************************
      #CONVERT TO PLY FORMAT
      #************************************************************************
      
      # Convert numpy array to .ply file
      # Create pointcloud class
      pcd = o3d.geometry.PointCloud()

      # Convert float64 numpy array of shape (n, 3) to Open3D format.
      pcd.points = o3d.utility.Vector3dVector(new_array)

      # Save new Open3D format pointcloud to .ply format
      o3d.io.write_point_cloud(output_folder + "/" + filename[:-4] + ".ply", pcd)

      print(filename[:-4] + " has succesfully converted!")

    else:
        continue

off_to_ply()


